/*
 *
 * (C) 2014 David Lettier.
 * (C) 2024 Benson Muite
 *
 * http://www.lettier.com/
 *
 * NTP client.
 *
 * Compiled with gcc (GCC) 14.2.1 20240912 (Red Hat 14.2.1-3).
 *
 * To compile: $ gcc main.c -o ntpClient.out
 *
 * Usage: $ ./ntpClient.out
 *
 */

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#define NTP_TIMESTAMP_DELTA 2208988800ull

#define LI(packet)   (uint8_t) ((packet.li_vn_mode & 0xC0) >> 6) // (li   & 11 000 000) >> 6
#define VN(packet)   (uint8_t) ((packet.li_vn_mode & 0x38) >> 3) // (vn   & 00 111 000) >> 3
#define MODE(packet) (uint8_t) ((packet.li_vn_mode & 0x07) >> 0) // (mode & 00 000 111) >> 0

void error( char* msg )
{
    perror( msg ); // Print the error message to stderr.

    exit( 0 ); // Quit the process.
}

int main( int argc, char* argv[ ])
{

  int sockfd;       // Socket file descriptor.

  int n;            // Return result from writing/reading the socket.

  int portno = 10123; //123; // NTP UDP port number.

  char * host_name = "localhost"; //"us.pool.ntp.org"; // NTP server hots-name.

  // Structure that defines the 48 byte NTP packet protocol.
  #pragma pack(1)
  typedef struct
  {
    uint8_t li_vn_mode;      // 8 bits. li, vn and mode.
                             // li.   Two bits. Leap indicator.
                             // vn.   Three bits. Version number of the protocol.
                             // mode. Three bits. Client will pick mode 3 for client.
    
    uint8_t stratum;         // 8 bits. Stratum level of the local clock.
    uint8_t poll;            // 8 bits. Maximum interval between successive messages.
    uint8_t precision;       // 8 bits. Precision of the local clock.

    uint8_t timescale;       // 8 bits. Requested timescale,
                             //    0: UTC, 1: TAI, 2: UT1, 3: Leap-smeared UTC
    uint8_t era;             // 8 bits. Era number of receive timestamp. 0 in requests.
                             //    0x1: Unknown leap
                             //    0x2: Interleaved mode if 1
                             //    0x4: Authentication NAK. 0 in requests. If 1 in response,
                             //         server failed to authenticate request, stratum
                             //         SHOULD be set to 0.
    uint16_t flags;          // 16 bits.   
    uint32_t rootDelay;      // 32 bits. Total round trip delay time.
    uint32_t rootDispersion; // 32 bits. Max error allowed from primary clock source.

    uint64_t serverCookie;   // 64 bits. Number generated by server enabling interleaved
                             //          mode. In requests, 0 or copy of server cookie
                             //          from the last response.
    uint64_t clientCookie;   // 64 bits. Random number generated by client. Responses
                             //          have a copy of the field from corresponding
                             //          request.
    
    uint32_t rxTm_s;         // 32 bits. Received time-stamp seconds.
    uint32_t rxTm_f;         // 32 bits. Received time-stamp fraction of a second.

    uint32_t txTm_s;         // 32 bits. Transmit time-stamp seconds.
    uint32_t txTm_f;         // 32 bits. Transmit time-stamp fraction of a second.
    
    uint16_t draftIdExType;  // 16 bits. Draft Identification Extension Field Type
    uint16_t draftIdExLength;// 16 bits. Draft Identification Extension Field Length
    uint8_t draftIdExData[24];  // 24*8 bits. Draft Identification Extension Field Data

  } ntp_packet;              // Total: 608 bits or 76 bytes.

  // Create and zero out the packet.

  ntp_packet packet;
  packet.li_vn_mode = 0;
  packet.stratum = 0;
  packet.poll = 0;
  packet.stratum = 0;
  packet.timescale = 0;
  packet.era = 0;
  packet.flags = 0;
  packet.rootDelay = 0;
  packet.rootDispersion = 0;
  packet.serverCookie = 0;
  packet.clientCookie = 0;
  packet.rxTm_s = 0;
  packet.rxTm_f = 0;
  packet.txTm_s = 0;
  packet.txTm_f = 0;
  packet.draftIdExType = 0;
  packet.draftIdExLength = 0;
  for(int i = 0; i <24; i++) packet.draftIdExData[i] = 0;
  
  memset( &packet, 0, sizeof( ntp_packet ) );

  // Set the first byte's bits to 00,101,011 for li = 0, vn = 5 and mode = 3.

  *( ( char * ) &packet + 0 ) = 0x2b;

  // Represents 43 in base 10 or 00 101 011 in base 2.

  // Set extension header byte bits to 0xF5FF;

  *( ( uint8_t * ) &packet + 48 ) = 0xf5;
  *( ( uint8_t * ) &packet + 49 ) = 0xff;
  // Length of data packet in octets
  *( ( uint8_t * ) &packet + 50 ) = 0x00;
  *( ( uint8_t * ) &packet + 51 ) = 0x1c;
  // Data - draft version number
  // draft-ietf-ntp-ntpv5-02
  *( ( char * ) &packet + 52 ) = 0x64;
  *( ( char * ) &packet + 53 ) = 0x72;
  *( ( char * ) &packet + 54 ) = 0x61;
  *( ( char * ) &packet + 55 ) = 0x66;
  *( ( char * ) &packet + 56 ) = 0x74;
  *( ( char * ) &packet + 57 ) = 0x2D;
  *( ( char * ) &packet + 58 ) = 0x69;
  *( ( char * ) &packet + 59 ) = 0x65;
  *( ( char * ) &packet + 60 ) = 0x74;
  *( ( char * ) &packet + 61 ) = 0x66;
  *( ( char * ) &packet + 62 ) = 0x2D;
  *( ( char * ) &packet + 63 ) = 0x6E;
  *( ( char * ) &packet + 64 ) = 0x74;
  *( ( char * ) &packet + 65 ) = 0x70;
  *( ( char * ) &packet + 66 ) = 0x2D;
  *( ( char * ) &packet + 67 ) = 0x6E;
  *( ( char * ) &packet + 68 ) = 0x74;
  *( ( char * ) &packet + 69 ) = 0x70;
  *( ( char * ) &packet + 70 ) = 0x76;
  *( ( char * ) &packet + 71 ) = 0x35;
  *( ( char * ) &packet + 72 ) = 0x2D;
  *( ( char * ) &packet + 73 ) = 0x30;
  *( ( char * ) &packet + 74 ) = 0x32;
  
  // Create a UDP socket, convert the host-name to an IP address, set the port number.
  // connect to the server, send the packet, and then read in the return packet.

  struct sockaddr_in serv_addr;  // Server address data structure.
  struct hostent *server;        // Server data structure.

  sockfd = socket ( AF_INET, SOCK_DGRAM, IPPROTO_UDP); // Create a UDP socket.

  if ( sockfd < 0 )
    error( "ERROR opening socket" );

  server = gethostbyname( host_name );  // Convert URL to IP.

  if ( server == NULL )
    error( "ERROR, no such host" );

  // Zero out the server address structure.

  bzero( ( char* ) &serv_addr, sizeof( serv_addr ) );

  serv_addr.sin_family = AF_INET;

  // Copy the server's IP address to the server address structure.

  bcopy( ( char* )server->h_addr, ( char* ) &serv_addr.sin_addr, server->h_length );

  // Convert the port number integer to network big-endian style and save it to the
  // server address structure.

  serv_addr.sin_port = htons( portno );

  // Call up the server using its IP address and port number.

  if ( connect( sockfd, ( struct sockaddr * ) &serv_addr, sizeof( serv_addr) ) < 0 )
    error( "ERROR conecting");
  // Send it the NTP packet it wants. If n == -1, it failed.

  n = write( sockfd, ( char* ) &packet, sizeof( ntp_packet ) );

  if ( n < 0 )
    error( "ERROR writing to socket" );
  // Wait and receive the packet back from the server.  If n == -1, it failed.

  n = read( sockfd, ( char* ) &packet, sizeof( ntp_packet ) );

  if ( n < 0 )
    error( "ERROR reading from socket" );
  // These two fields contain the time-stamp seconds as the packet left the NTP server.
  // The number of seconds correspond to the second passed since 1900.
  // ntohl() converts the bit/byte order from the networks' to the hosts' endianness.

  packet.txTm_s = ntohl( packet.txTm_s ); // Time-stamp seconds.
  packet.txTm_f = ntohl( packet.txTm_f ); // Time-stamp fraction of a second.

  // Extract the 32 bits that represent the time-stamp seconds (since NTP epoch) from
  // when the packet left the server.
  // Subtract 70 years worth of seconds from the seconds since 1900.
  // This leave the seconds since the UNIX epoch of 1970.
  // (1900)-----------------(1970)******************************(Time packet Left the Server)

  time_t txTm = ( time_t ) ( packet.txTm_s - NTP_TIMESTAMP_DELTA );
  // Print the time we got from the server, accounting for the local timezone and
  // conversion from UTC time.

  printf( "Time: %s\n", ctime( ( const time_t* ) &txTm ) );

  return 0;
}
